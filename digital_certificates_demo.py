from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from hashlib import sha256


if __name__ == '__main__':

    """
    The author creates a message to be signed. 
    """
    msg = 'The password is dog123!'

    """
    2. The certificate authority (CA) generates a signature by encrypting the message hash using it's private key.
    """
    hash = sha256(msg.encode('utf-8')).hexdigest().encode('utf-8')

    print("HASH", hash, '\n')

    private_key = rsa.generate_private_key( # Ignore the fact that the 'public key' is being used to encrypt the message. What defines the public and private keys is whether they are shared publicly or kept private!
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )

    public_key = private_key.public_key()

    signature = public_key.encrypt(hash, padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None))

    print('SIGNATURE:', signature, '\n')

    """
    3. To validate the signature, first decrypt it using the CA's public key. If the output of this is
    equal to the message hash then you must know that the signature was generated by the CA (a trusted third-party)
    and therefore the message is legitimate."""
    decrypted_sig = private_key.decrypt(signature, padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None))

    print('DECRYPTED SIGNATURE', decrypted_sig, '\n')

    if hash == decrypted_sig:
        print('Certificate validated successfully!')
